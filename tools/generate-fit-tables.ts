import { Profile, SubField } from "@garmin/fitsdk";

console.log(
  `// GENERATED BY:\n`,
  `// % node build/tools/generate-fit-tables.js > src/fit-tables.tmp && mv src/fit-tables.{tmp,ts}\n`
);

console.log(`import type { FitField } from "@garmin/fitsdk"`);
console.log(`export type FitRawTypes = keyof typeof fit_types;`);
console.log(
  `export type FitBaseTypes = Exclude<keyof typeof fit_types.fit_base_type, "_min"| "_max">;`
);
console.log(`export type FitTypes = FitRawTypes|FitBaseTypes;`);
console.log(`export type FitExtraTypes = FitTypes | "bool";`);

console.log("export type FitTypeMap = Record<string, Record<string, number>>;");
console.log("export type ExtFitField = FitField & { type: FitExtraTypes };");
console.log(
  "export type FitMessageMap = Record<string, {value:number; name:string; fields:Record<string,ExtFitField>}>;"
);

function deCamelize(s: unknown): unknown {
  if (typeof s === "string") {
    const rep = s.replace(
      /([^A-Z])([A-Z]+)/g,
      (m, p1: string, p2: string) =>
        p1 + "_" + p2.toLowerCase().split("").join("_")
    );
    if (/[A-Z]/.test(rep)) {
      throw new Error(`Unexpected upper case letters in: ${rep}`);
    }
    return rep;
  }
  if (typeof s === "number" || typeof s === "boolean" || s == null) return s;
  if (Array.isArray(s)) {
    return s.map((v) => deCamelize(v));
  }
  return Object.fromEntries(
    Object.entries(s).map(([key, value]) => [
      key !== "isAccumulated" && key !== "hasComponents" && key !== "subFields"
        ? deCamelize(key)
        : key,
      key === "name" ||
      key === "type" ||
      key === "subFields" ||
      typeof value === "object"
        ? deCamelize(value)
        : value,
    ])
  );
}

const FIT = {
  types: deCamelize(Profile.types) as typeof Profile.types,
  messages: deCamelize(Profile.messages) as typeof Profile.messages,
};

const fit_types = Object.fromEntries(
  Object.entries(FIT.types)
    .concat([
      [
        "device_index",
        {
          0: 0,
          254: 254,
        },
      ],
    ])
    .map(([key, value]) => {
      let max = -Infinity;
      let min = Infinity;
      const mapped = Object.entries(value).map(([k, v]) => {
        const num = Number(k);
        if (isNaN(num) || num !== Math.round(num)) {
          throw new Error(`expected a number, but got "${k}"`);
        }
        if (num < min) min = num;
        if (num > max) max = num;
        return [v, num] as const;
      });
      if (min > max) max = min = 0;
      mapped.forEach(([k, v]) => {
        if (typeof k === "string" && /^[a-zA-Z_]+$/.test(k)) {
          const snake = deCamelize(k) as string;
          if (snake !== k) {
            mapped.push([snake, v]);
          }
        }
      });
      mapped.sort(([, a], [, b]) => a - b);
      mapped.push(["_min", min], ["_max", max]);

      return [key, Object.fromEntries(mapped)] as const;
    })
);

console.log(
  `export const fit_types = ${JSON.stringify(
    fit_types,
    undefined,
    "  "
  )} as const satisfies FitTypeMap;\n`
);

const fit_messages = Object.fromEntries(
  Object.entries(FIT.messages).map(([key, value]) => {
    const mapped = Object.values(value.fields).map(
      (val) => [val.name, val] as const
    );
    if (!value.name) {
      throw new Error(`Missing name in key ${key}: ${JSON.stringify(value)}`);
    }
    const num = value.num;
    if (isNaN(num) || num !== Math.round(num)) {
      throw new Error(`expected a number, but got "${value.num}"`);
    }
    return [
      value.name,
      { value: num, name: value.name, fields: Object.fromEntries(mapped) },
    ] as const;
  })
);

console.log(
  `export const fit_messages = ${JSON.stringify(
    fit_messages,
    undefined,
    "  "
  )} as const satisfies FitMessageMap;\n`
);

const base_types = Object.fromEntries(
  Object.keys(fit_types.fit_base_type)
    .concat("bool")
    .map((k) => [k, true] as const)
);

console.log(`export type FitMessageInputs = {`);
Object.entries(fit_messages).forEach(([key, value]) => {
  const entries = Object.entries(value.fields);
  if (!entries.length) {
    console.log(`  ${key}: Record<string,never>;`);
    return;
  }
  console.log(`  ${key}: {`);
  const getType = (
    k: string,
    v: (typeof value)["fields"][string] | SubField
  ): string[] => {
    const type = v.type in fit_types ? fit_types[v.type] : base_types[v.type];
    if (!type) {
      throw new Error(`Missing fit_type: ${v.type}`);
    }
    const typestrs: string[] = [];
    if ("subFields" in v && v.subFields?.length) {
      typestrs.push(
        "number",
        ...v.subFields.flatMap((f) => getType(f.name, f))
      );
    } else if (v.hasComponents && v.components.length > 1) {
      typestrs.push(
        `[${v.components
          .map((c) => {
            const n = Number(c);
            const e = Object.values(value.fields).find((f) => f.num === n);
            if (!e) {
              throw new Error(
                `Expected a component index, but got ${c} at ${key}:${k}`
              );
            }
            return `FitMessageInputs["${key}"]["${e.name}"]`;
          })
          .join(",")}]`
      );
    } else if (v.type === "string") {
      typestrs.push("string");
    } else if (v.array === "true") {
      typestrs.push("number[]");
    } else if (type === true) {
      typestrs.push("number");
    } else if ("mask" in type) {
      typestrs.push(
        `{ value: number; options?:(${Object.keys(type)
          .filter(
            (k) =>
              k !== "mask" && k !== "_min" && k !== "_max" && isNaN(Number(k))
          )
          .map((k) => JSON.stringify(k))
          .join("|")})[]}`
      );
    } else {
      typestrs.push(
        ...Object.keys(type)
          .filter((k) => k !== "_min" && k !== "_max" && isNaN(Number(k)))
          .map((k) => JSON.stringify(k))
      );
      if (
        typestrs.length === 0 ||
        (typestrs.length === 1 && typestrs[0] === '"min"')
      ) {
        typestrs[0] = "number";
      }
    }
    if (k === "fit_base_type_id") {
      typestrs.push("number");
    }
    return typestrs.flatMap((s) => {
      if (/^"[a-zA-Z_]+"$/.test(s)) {
        const snake = deCamelize(s) as string;
        if (snake !== s) return [snake, s];
      }
      return s;
    });
  };
  entries.forEach(([k, v]) => {
    const typestr = getType(k, v)
      .sort()
      .filter((s, i, a) => s !== a[i - 1])
      .join("|");
    console.log(`    ${k}: ${typestr};`);
  });
  console.log(`  };`);
});
console.log(`};`);
